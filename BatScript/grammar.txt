program       -> statement* EOF

type          -> ( "int" | "float" | "bool" | "string" | IDENTIFIER ) ( "[" ( expression )? "]" )*

statement     -> simple_stmt | compound_stmt
simple_stmt   -> expression eol
               | print_stmt
               | return_stmt
               | import_stmt
               | native_stmt
compound_stmt -> if_stmt
               | while_stmt
               | for_stmt
               | var_decl
               | function_decl

block         -> indent statement+ dedent

var_decl      -> ("var" | "const" | type) IDENTIFIER ("=" expression)? ("," IDENTIFIER ("=" expression)?)* eol
function_decl -> ("def" | type) IDENTIFIER "(" parameters? ")" ":" (eol block | simple_stmt)

print_stmt    -> "print" expression eol

if_stmt       -> "if" expression ":" (eol block | simple_stmt) ("else" (eol block | simple_stmt))?
while_stmt    -> "while" expression ":" (eol block | simple_stmt)
for_stmt      -> "for" "(" expression? ";" expression? ";" expression? ")" block // Ignore me for now :)

return_stmt   -> "return" expression? eol

import_stmt   -> "import" IDENTIFIER eol
native_stmt   -> "native" type IDENTIFIER "(" parameters? ")" eol

parameter     -> type IDENTIFIER ( "=" expression )?
parameters    -> parameter ( "," parameter )* ( "," "..." )?

expression    -> assign
assign        -> or ( ( "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "^=" | "|=" ) or )*
or            -> and ( "or" and )*
and           -> bitor ( "and" bitor )*
bitor         -> bitxor ( "|" bitxor )*
bitxor        -> bitand ( "^" bitand )*
bitand        -> equal ( "&" equal )*
equal         -> comp ( ( "==" | "!=" ) comp )*
comp          -> shift ( ( "<" | "<=" | ">=" | ">" ) shift )*
shift         -> add ( ( "<<" | ">>" ) add )*
add           -> mult ( ( "+" | "-" ) mult )*
mult          -> unary ( ( "*" | "/" | "%" ) unary )*
unary         -> ( "+" | "-" | "!" | "~" | "*" | "&" | "print" ) unary
               | call
call          -> primary ( ( "(" arguments? ")" ) | ( "[" expression "]" ) )*
arguments     -> expression ( "," expression )*
primary       -> NUMBER | STRING | "false" | "true" | "null" // Literals
               | "(" expression ")" // Grouping
               | "[" array_values? "]" // Array literal
array_values  -> expression ( "," expression )* ","? // Optional trailing comma